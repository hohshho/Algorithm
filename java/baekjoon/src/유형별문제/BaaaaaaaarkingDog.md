# 기초 코드 작성 요령

- 1초에 3억 ~ 5억개 연산 처리
- O(n)인 경우 10,000,000개 이하라 생각
- O(n*n)인 경우 5,000개 이하라 생각
- 500MB = 1.2억 int
- int = 21억까지

# 배열

- 임의의 위치에 원소 확인 / 변경 = O(1)
- 원소 끝에 추가 / 제거  = O(1)
- 임의의 위치에 원소 추가 / 제거 = O(N)

# 연결리스트

- 임의의 위치에 있는 원소 확인 / 변경 = O(N)
- 임의의 위치에 원소 추가 / 제거 = O(1)
- **임의의 위치에 원소를 추가 / 제거하는 경우 좋음**

# 스택 (FILO First In Last Out)
> 한쪽 끝에서만 원소 넣거나 뺼 수 있는 구조

- 원소 추가가 O(1)
- 원소 제거가 O(1)
- 상단 원소 확인 O(1)
- 나머지 원소 확인, 변경이 원칙적으로 불가능

```text
pop() : 가장 나중에 넣은 데이터 삭제
push() : 데이터 추가
peek() : 가장 나중에 넣은 데이터 확인
isEmpty() : 비어있는지 확인
size() : 스택에 있는 요소 크기 반환
```

# 큐 (FIFO First In First Out)
> 한쪽 끝에서 원소넣고 반대쪽에서 뺼 수 있는 자료구조

- 원소 추가 O(1)
- 원소 제거 O(1)
- 제일 앞, 뒤 원소 확인 O(1)
- 제일 앞, 뒤 원소확인 가능, 변경이 원칙적 불가능

```text
add() : 맨 뒤에 값 삽입 (반환)
poll() : 맨 앞 값 제거 (반환)
offer() : 맨 뒤에 값 삽입
remove() : 맨 앞 값 제거
peek() : 맨 앞 요소 반환 // 오리픽
```

# 덱
> 양쪽 끝에서 삽입과 삭제 전부 가능

- 원소 추가 O(1)
- 원소 제거 O(1)
- 제일 앞, 뒤 원소 확인 O(1)
- 제일 앞, 뒤 아닌 나머지 원소 확인 원칙적으로 불가능

```text
add() :
addLast() :
addFirst() : 
...

엄청 많음 이건 문서보고 사용
```

# BFS

## 1. 거리 측정

[백준 2178](https://www.acmicpc.net/problem/2178) 
- 거리를 Node안에 같이 넣어서 계산
- dist를 따로 저장 -> dist[n][m] 꺼내면 된다.

## 2. 시작점이 여러 개일 때

[백준 7576](https://www.acmicpc.net/problem/7576)
- 그냥 시작점 전부 넣으면 된다.
- BFS를 돌 때 큐에 쌓이는 순서는 **반드시 거리 순**

## 3. 시작점이 두 종류일 때

[백준 4179](https://www.acmicpc.net/problem/4179)
- 하나의 dist배열을 구한다
- 나머지 하나의 dist배열을 구함
  - 구할 떄 먼저 구한 dist배열로 조건 처리

불! 문제는 A, B 서로가 영향을 주지 않으니까 따로 돌려도 되는데
A, B 상황이 서로한테 영향을 주면 해결 못함 (백트래킹 필요)

## 4. 1차원에서의 BFS

[백준 1697](https://www.acmicpc.net/problem/1697)

- 2차원이랑 동일하게

# DFS

BFS에서 Queue를 stack으로 바꾼 것

# 재귀

- 재귀로 푼다 == 귀납적인 방식으로 문제해결

재귀 조건
- 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료
- 모든 입력은 **base condition**으로 수렴해야 함

재귀 정보
- 함수의 인자로 어떤 것을 받고, 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확히 정해야 한다.
- 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
- 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리, 시간에 손해를 본다
- 한 함수가 자기 자신을 여러번 호출하게 되면 비효율적일 수 있음
- 재귀함수가 자기 자신을 부를 떄 스택영역에 계속 누적이 됨

문제 풀 때 
1. 함수의 정의
2. base condition
3. 재귀 식

인데 솔직히 이해가 안감. 재귀, 백트래킹은 넘기자